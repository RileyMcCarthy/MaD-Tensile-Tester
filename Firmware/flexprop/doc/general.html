<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Total Spectrum Software" />
  <meta name="dcterms.date" content="2022-07-22" />
  <title>FlexProp Reference</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">FlexProp Reference</h1>
<p class="subtitle">5.9.14</p>
<p class="author">Total Spectrum Software</p>
<p class="date">07/22/2022</p>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#general-compiler-features">General Compiler Features</a><ul>
<li><a href="#languages">Languages</a><ul>
<li><a href="#spin-obj-blocks">Spin OBJ blocks</a></li>
<li><a href="#objects-in-other-languages">Objects in other languages</a></li>
</ul></li>
<li><a href="#fast-cache-fcache">Fast Cache (Fcache)</a><ul>
<li><a href="#what-loops-will-be-placed-in-fcache">What loops will be placed in fcache</a></li>
</ul></li>
<li><a href="#inline-assembly">Inline assembly</a><ul>
<li><a href="#restrictions-in-inline-assembly">Restrictions in inline assembly</a></li>
<li><a href="#inline-assembly-in-bytecode">Inline assembly in bytecode</a></li>
</ul></li>
<li><a href="#functions-in-cog-or-lut-memory">Functions in COG or LUT memory</a><ul>
<li><a href="#spinspin2">Spin/Spin2</a></li>
<li><a href="#basic">BASIC</a></li>
<li><a href="#cc">C/C++</a></li>
</ul></li>
<li><a href="#interrupt-service-routines">Interrupt Service Routines</a></li>
<li><a href="#abort--try--catch">ABORT / TRY / CATCH</a><ul>
<li><a href="#spin-and-spin2">Spin and Spin2</a></li>
<li><a href="#basic-and-c">BASIC and C</a></li>
</ul></li>
<li><a href="#register-usage">Register Usage</a><ul>
<li><a href="#p1">P1</a></li>
<li><a href="#p2">P2</a></li>
</ul></li>
<li><a href="#memory-map">Memory Map</a><ul>
<li><a href="#hub">HUB</a></li>
<li><a href="#cog">COG</a></li>
<li><a href="#lut">LUT</a></li>
</ul></li>
<li><a href="#optimizations">Optimizations</a><ul>
<li><a href="#multiplication-conversion-always">Multiplication conversion (always)</a></li>
<li><a href="#unused-method-removal--o1--oremove-unused">Unused method removal (-O1, -Oremove-unused)</a></li>
<li><a href="#unused-feature-removal--o1--oremove-features">Unused feature removal (-O1, -Oremove-features)</a></li>
<li><a href="#dead-code-elimination--o1--oremove-dead">Dead code elimination (-O1, -Oremove-dead)</a></li>
<li><a href="#small-method-inlining--o1--oinline-small">Small Method inlining (-O1, -Oinline-small)</a></li>
<li><a href="#register-optimization--o1--oregs">Register optimization (-O1, -Oregs)</a></li>
<li><a href="#local-register-reuse--o1--olocal-reuse">Local register reuse (-O1, -Olocal-reuse)</a></li>
<li><a href="#branch-elimination--o1--obranch-convert">Branch elimination (-O1, -Obranch-convert)</a></li>
<li><a href="#constant-propagation--o1--oconst">Constant propagation (-O1, -Oconst)</a></li>
<li><a href="#peephole-optimization--o1--opeephole">Peephole optimization (-O1, -Opeephole)</a></li>
<li><a href="#tail-call-optimization--o1--otail-calls">Tail call optimization (-O1, -Otail-calls)</a></li>
<li><a href="#loop-optimization--o1--oloop-basic">Loop optimization (-O1, -Oloop-basic)</a></li>
<li><a href="#fcache--o1--ofcache">Fcache (-O1, -Ofcache)</a></li>
<li><a href="#bytecode-macro-creation--o1--obcmacros">Bytecode Macro creation (-O1, -Obcmacros)</a></li>
<li><a href="#special-function-handling--o1--ospecial-functions">Special Function handling (-O1, -Ospecial-functions)</a></li>
<li><a href="#reorder-instructions-for-cordic--o1--ocordic-reorder">Reorder instructions for Cordic (-O1, -Ocordic-reorder)</a></li>
<li><a href="#single-use-method-inlining--o2--oinline-single">Single Use Method inlining (-O2, -Oinline-single)</a></li>
<li><a href="#common-subexpression-elimination--o2--ocse">Common Subexpression Elimination (-O2, -Ocse)</a></li>
<li><a href="#loop-strength-reduction--o2--oloop-reduce">Loop Strength Reduction (-O2, -Oloop-reduce)</a></li>
<li><a href="#per-function-control-of-optimizations">Per-function control of optimizations</a></li>
<li><a href="#optimization-control-on-the-command-line">Optimization control on the command line</a></li>
<li><a href="#optimizing-for-size">Optimizing for size</a></li>
</ul></li>
<li><a href="#memory-allocation-and-management">Memory Allocation and Management</a><ul>
<li><a href="#heap-allocation">Heap allocation</a></li>
<li><a href="#heap-size-specification">Heap size specification</a></li>
<li><a href="#garbage-collection">Garbage collection</a></li>
<li><a href="#stack-allocation">Stack allocation</a></li>
</ul></li>
<li><a href="#terminal-control">Terminal Control</a><ul>
<li><a href="#changing-baud-rate">Changing baud rate</a></li>
<li><a href="#changing-echo-and-crlf-interpretation">Changing echo and CR/LF interpretation</a></li>
</ul></li>
<li><a href="#character-set">Character Set</a></li>
<li><a href="#file-io-p2-only">File I/O (P2 Only)</a><ul>
<li><a href="#mount">Mount</a></li>
<li><a href="#options-for-sd-card">Options for SD Card</a></li>
</ul></li>
<li><a href="#command-line-options">Command Line Options</a><ul>
<li><a href="#options-for-flexspin">Options for flexspin</a></li>
<li><a href="#options-for-flexcc">Options for flexcc</a></li>
<li><a href="#changing-hub-address">Changing Hub address</a></li>
</ul></li>
<li><a href="#common-low-level-functions">Common low level functions</a><ul>
<li><a href="#serial-port-access">Serial port access</a></li>
<li><a href="#time-related-functions">Time related functions</a></li>
<li><a href="#cog-control">Cog control</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
<h1 id="general-compiler-features">General Compiler Features</h1>
<p>This document describes compiler features common to all of the Flex languages.</p>
<h2 id="languages">Languages</h2>
<p>The compiler supports Spin (in both Spin 1 and Spin 2 variants), C (and a subset of C++), and BASIC. The choice of which language to use is determined by the file extension.</p>
<h3 id="spin-obj-blocks">Spin OBJ blocks</h3>
<p>In Spin OBJ blocks, the default extension for file names is the same as the file name of the source file; that is:</p>
<pre><code>  OBJ
    a: &quot;somedevice&quot;
</code></pre>
<p>will look for "somedevice.spin2" first in a .spin2 file, then "somedevice.spin"; in a .spin file the order is reversed.</p>
<p>In order to avoid ambiguity it is suggested that the file name extension always be explicitly given. An explicit file name is always required for non-Spin objects:</p>
<pre><code>  OBJ
    a: &quot;somedevice.spin&quot;
    b: &quot;otherdevice.bas&quot;
</code></pre>
<h3 id="objects-in-other-languages">Objects in other languages</h3>
<p>In BASIC <code>class using</code> and C <code>struct __using</code> the full filename of the source object, including extension, must always be used.</p>
<p>BASIC and C also allow inline declarations of classes, using <code>class</code>. See the respective language documents for more details.</p>
<h2 id="fast-cache-fcache">Fast Cache (Fcache)</h2>
<p>Fcache is a special feature of the compiler whereby small loops are copied from HUB memory into local (COG) memory before execution. This speeds up repated loops quite a bit. Fcache is available only if optimization is enabled.</p>
<p>Some inline assembly blocks may also be marked to be copied to fcache before execution; see the section on inline assembly for a description of this.</p>
<h3 id="what-loops-will-be-placed-in-fcache">What loops will be placed in fcache</h3>
<p>Loops will be placed in fcache only if (a) they will fit, and (b) they contain no branches to outside the loop (including subroutine calls). The size of the fcache may be set by the <code>--fcache</code> flag, but is generally 1024 bytes on P2 and 128 bytes on P1.</p>
<h2 id="inline-assembly">Inline assembly</h2>
<p>All of the languages allow inline assembly within functions. There are 3 different forms of inline assembly:</p>
<p>(1) Plain inline assembly. This is generated by <code>asm</code>/<code>endasm</code> in Spin and BASIC, and from an <code>__asm { }</code> block in C. These blocks run in hubexec mode (for P2) or LMM (for P1) and are optimized by the optimizer.</p>
<p>(2) HUB non-optimized assembly. This is generated by <code>const asm</code>/<code>end asm</code> in BASIC and <code>__asm const{}</code> in C; it is not currently available in Spin. Like plain assembly this runs from HUB, but is not subject to optimization.</p>
<p>(3) FCACHEd non-optimized assembly. This is generated by <code>org</code>/<code>end</code> in Spin, <code>cpu asm</code>/<code>end asm</code> in BASIC, and <code>__asm volatile{}</code> in C. This is not subject to optimization, and before execution it is loaded into the FCACHE area, so its timing is based on running from internal memory rather than HUB.</p>
<h3 id="restrictions-in-inline-assembly">Restrictions in inline assembly</h3>
<p>Inline assembly within a function follows a different path through the compiler than "regular" assembly in a DAT section (Spin) or <code>shared asm</code> (BASIC). This has a number of consequences; not all constructions will work properly, and the inline assembly can be limited.</p>
<h4 id="only-local-variables">Only local variables</h4>
<p>Only hardware registers and variables local to the function may be used in inline assembly. Global or method variables may not be referenced.</p>
<h4 id="local-variables-not-usable-in-some-functions">Local variables not usable in some functions</h4>
<p>If a function takes the address of a parameter, or of a local variable, then its local variables are placed on the stack and may not be referred to in inline assembly.</p>
<h4 id="no-branches-outside-the-function">No branches outside the function</h4>
<p>Branching within a function is supported in inline assembly, but trying to branch outside the function or to call another function is not supported. The results are undefined; calls in particular may appear to work in some cases, but then fail when the called function is modified.</p>
<p>It is also not legal to return from inside inline assembly. For Spin2, returns are automatically converted to jumps to the end of the inline assembly (this is for compatibility with PNut), but it's probably better to write this explicitly yourself.</p>
<h4 id="no-register-declarations">No register declarations</h4>
<p>Do not try to declare registers; the inline assembly probably will not be running from COG memory. If you need some scratch registers in inline assembly, declare them as local variables in the function. The only exception to this is <code>ORG</code> in Spin2, or the similar constructs like <code>cpu asm</code> or <code>asm volatile</code> in C, where the inline assembly is guaranteed to be placed in COG memory. It's still probably better to declare local variables instead of placing register declarations in the inline assembly, though.</p>
<h4 id="general-guidelines">General Guidelines</h4>
<p>Try to keep inline assembly as simple as possible. Use the high level language for loops and conditional control structures; the high level language is there for a reason!</p>
<h3 id="inline-assembly-in-bytecode">Inline assembly in bytecode</h3>
<p>Inline assembly is not supported in Spin1 bytecode (<code>--interp=rom</code>). It will produce a compile time error. It is supported in Nu bytecode (<code>-2nu</code>) but hasn't been thoroughly tested in that mode.</p>
<h2 id="functions-in-cog-or-lut-memory">Functions in COG or LUT memory</h2>
<p>Normally functions are placed in HUB memory, because there is a lot more of that. However, it is possible to force some functions to be placed in the chip's internal memory, where they will execute much more quickly. This must be done with care, because internal memory is a very limited resource.</p>
<p>Only small functions should be placed in internal memory. It's probably better if these functions do not call any functions in HUB, at least in the normal case, since any speed advantage of placing a function in COG or LUT will be negated if it calls out to HUB.</p>
<p>Functions in COG or LUT memory are not supported in bytecode output (e.g. <code>--interp=rom</code>).</p>
<h3 id="spinspin2">Spin/Spin2</h3>
<p>To put a method into COG memory, place a special comment <code>{++cog}</code> after the <code>PUB</code> or <code>PRI</code> declaration of the method.</p>
<pre><code>  pub {++cog} add(x, y)
    return x+y
</code></pre>
<p>Similarly, to put the method into LUT memory (on the P2 only, obviously) then use the comment <code>{++lut}</code>.</p>
<h3 id="basic">BASIC</h3>
<p>Place the keyword <code>for</code> before the function or subroutine's name in its declaration, followed by a string specifying the memory (<code>"cog"</code> or <code>"lut"</code>):</p>
<pre><code>function for &quot;cog&quot; toupper(c as ubyte) as ubyte
  if c &gt;= asc(&quot;a&quot;) and c &lt;= asc(&quot;z&quot;) then
    c = c + (asc(&quot;A&quot;) - asc(&quot;a&quot;))
  end if
  return c
end function
</code></pre>
<h3 id="cc">C/C++</h3>
<p>Place <code>__attribute__((cog))</code> after the function declaration but before its body:</p>
<pre><code>int add(int x, int y) __attribute__((cog))
{
  return x+y;
}
</code></pre>
<p>Similarly use <code>__attribute__((lut))</code> to place the function into LUT memory.</p>
<h2 id="interrupt-service-routines">Interrupt Service Routines</h2>
<p>The code generated by FlexSpin is <em>not</em> interrupt safe, so it is not possible to run interrupt service routines (ISRs) in the same COG as compiled code. ISRs may, of course, run in COGs that contain only PASM code launched by <code>coginit</code>.</p>
<h2 id="abort--try--catch">ABORT / TRY / CATCH</h2>
<p>All of the language supported by FlexSpin support some form of exception throwing or catching.</p>
<h3 id="spin-and-spin2">Spin and Spin2</h3>
<p>Spin and Spin2 support only a subset of the functionality, in the form of the <code>ABORT</code> keyword and the <code>\</code> operator.</p>
<h3 id="basic-and-c">BASIC and C</h3>
<p>BASIC and C support <code>try</code> / <code>catch</code> which may execute arbitrary code when an exception is thrown. The block inside <code>try</code> is executed; if inside that block an error is thrown, the value is passed to the <code>catch</code> clause. If a Spin function called from BASIC or C executes <code>ABORT n</code>, the effect is as if it did a <code>throw n</code> (where <code>n</code> is an integer).</p>
<p>In C the try block is marked with <code>__try</code> and the catch block with <code>__catch</code>:</p>
<pre><code>   __try {
     x = someFunc();
     y = someOtherFunc();
   }
   __catch(int e) {
     printf(&quot;error number %d was thrown\n&quot;, e);
   }
</code></pre>
<p>In BASIC and C++ the normal <code>try</code> and <code>catch</code> keywords are supported.</p>
<p>For now only integer types are supported in <code>catch</code> clauses, and each <code>try</code> block should have only one <code>catch</code>. This restriction may be lifted at some time in the future to support typed <code>catch/throw</code>.</p>
<h2 id="register-usage">Register Usage</h2>
<p>These comments on register usage apply only to the default assembler output. Bytecode output (such as the Spin1 bytecode output enabled by <code>--interp=rom</code>) generally use all of the COG memory for the interpreter.</p>
<h3 id="p1">P1</h3>
<p>Pretty much all of COG RAM is used by the compiler. No specific hardware registers are used.</p>
<h3 id="p2">P2</h3>
<p>Most of COG RAM is used by the compiler, except that $1e0-$1ef are left free for application use. COG RAM from $00 to $ff is used for FCACHE, and so when you are sure no FCACHE is in use you may use this for scratch.</p>
<p>The second half of LUT memory (from $300 to $3ff) may be used by compiler internal functions.</p>
<p><code>ptra</code> is used for the stack pointer. Applications should avoid using it.</p>
<p><code>pa</code> is used internally for fcache loading. Applications may use it as a temporary variable, but be aware that any code execution which may trigger an fcache load (e.g. any loop or subroutine call) may trash its value.</p>
<h2 id="memory-map">Memory Map</h2>
<h3 id="hub">HUB</h3>
<p>Code starts at 0 in HUB (by default, there are command line options to change this). Data starts after the code. The heap is part of the data area. The stack starts after this and grows upwards.</p>
<h3 id="cog">COG</h3>
<p>Most of COG RAM is used by the compiler, except that $1e0-$1ef is left free for application use.</p>
<h3 id="lut">LUT</h3>
<p>The first part of LUT memory (from $200 to $300) is used for any functions explicitly placed into LUT. The LUT memory from $300 to $400 (the second half of LUT) is used for internal purposes.</p>
<h2 id="optimizations">Optimizations</h2>
<p>Listed below are optimizations which may be enabled on the command line or on a per-function basis. The general optimization level may be specified by a number: 0 for no optimizations, 1 for basic (reliable) optimizations, and 2 for additional optimizations. <code>-Os</code> is generally equivalent to <code>-O1</code>, but favors size over speed (and may enable a few additional space optimizations).</p>
<h3 id="multiplication-conversion-always">Multiplication conversion (always)</h3>
<p>Multiplies by powers of two, or numbers near a power of two, are converted to shifts. For example</p>
<pre><code>    a := a*10
</code></pre>
<p>is converted to</p>
<pre><code>    a := (a&lt;&lt;3) + (a&lt;&lt;1)
</code></pre>
<p>A similar optimization is performed for divisions by powers of two.</p>
<h3 id="unused-method-removal--o1--oremove-unused">Unused method removal (-O1, -Oremove-unused)</h3>
<p>This is pretty standard; if a method is not used, no code is emitted for it. This optimization works at high level, so enabling/disabling it per function is not useful.</p>
<h3 id="unused-feature-removal--o1--oremove-features">Unused feature removal (-O1, -Oremove-features)</h3>
<p>Scans the program for certain library features (like file I/O and floating point usage) and disables those features if unused. This can save quite a bit of space. Depends on unused method removal to work properly/</p>
<h3 id="dead-code-elimination--o1--oremove-dead">Dead code elimination (-O1, -Oremove-dead)</h3>
<p>Within functions if code can obviously never be reached it is also removed. So for instance in something like:</p>
<pre><code>  CON
    pin = 1
  ... 
  if (pin == 2)
    foo
</code></pre>
<p>The if statement and call to <code>foo</code> are removed since the condition is always false.</p>
<h3 id="small-method-inlining--o1--oinline-small">Small Method inlining (-O1, -Oinline-small)</h3>
<p>Very small methods are expanded inline. This may be prevented by declaring the method with the "noinline" attribute.</p>
<h3 id="register-optimization--o1--oregs">Register optimization (-O1, -Oregs)</h3>
<p>The compiler analyzes assignments to registers and attempts to minimize the number of moves (and temporary registers) required.</p>
<h3 id="local-register-reuse--o1--olocal-reuse">Local register reuse (-O1, -Olocal-reuse)</h3>
<p>Reuse registers to reduce the number of temporary registers introduced. This may reduce the readability of the generated code somewhat, although that's probably moot at this stage because many other optimizations also make the code harder to read.</p>
<h3 id="branch-elimination--o1--obranch-convert">Branch elimination (-O1, -Obranch-convert)</h3>
<p>Short branch sequences are converted to conditional execution where possible.</p>
<h3 id="constant-propagation--o1--oconst">Constant propagation (-O1, -Oconst)</h3>
<p>If a register is known to contain a constant, arithmetic on that register can often be replaced with move of another constant.</p>
<h3 id="peephole-optimization--o1--opeephole">Peephole optimization (-O1, -Opeephole)</h3>
<p>In generated assembly code, various shorter combinations of instructions can sometimes be substituted for longer combinations.</p>
<h3 id="tail-call-optimization--o1--otail-calls">Tail call optimization (-O1, -Otail-calls)</h3>
<p>Convert recursive calls into jumps when possible</p>
<h3 id="loop-optimization--o1--oloop-basic">Loop optimization (-O1, -Oloop-basic)</h3>
<p>In some circumstances the optimizer can re-arrange counting loops so that the <code>djnz</code> instruction may be used instead of a combination of add/sub, compare, and branch. In -O2 a more thorough loop analysis makes this possible in more cases.</p>
<h3 id="fcache--o1--ofcache">Fcache (-O1, -Ofcache)</h3>
<p>Small loops are copied to internal memory (COG) to be executed there. These loops cannot have any non-inlined calls in them.</p>
<h3 id="bytecode-macro-creation--o1--obcmacros">Bytecode Macro creation (-O1, -Obcmacros)</h3>
<p>Some bytecode backends (e.g. the nucode one) are able to combine bytecodes to create macros. This saves considerable space in the generated code. Note that this option applies globally, and cannot be turned on/off per function.</p>
<h3 id="special-function-handling--o1--ospecial-functions">Special Function handling (-O1, -Ospecial-functions)</h3>
<p>Optimizes some specialized function calls for common cases. For example, in the general case pinwrite() has to handle being able to set ranges of bits, but in a special case where just one bit is being written it can be optimized to a _drvw(). Functions processed with this include:</p>
<p>pinread: Optimized if just one pin is read pinwrite: Optimized if just one pin or one bit are being written</p>
<h3 id="reorder-instructions-for-cordic--o1--ocordic-reorder">Reorder instructions for Cordic (-O1, -Ocordic-reorder)</h3>
<p>On the P2, reorder instructions to take advantage of cordic pipeline delays.</p>
<h3 id="single-use-method-inlining--o2--oinline-single">Single Use Method inlining (-O2, -Oinline-single)</h3>
<p>If a method is called only once in a whole program, it is expanded inline at the call site.</p>
<h3 id="common-subexpression-elimination--o2--ocse">Common Subexpression Elimination (-O2, -Ocse)</h3>
<p>Code like:</p>
<pre><code>   c := a*a + a*a
</code></pre>
<p>is automaticaly converted to something like:</p>
<pre><code>    tmp := a*a
    c := tmp + tmp
</code></pre>
<h3 id="loop-strength-reduction--o2--oloop-reduce">Loop Strength Reduction (-O2, -Oloop-reduce)</h3>
<h4 id="array-indexes">Array indexes</h4>
<p>Array lookups inside loops are converted to pointers. So:</p>
<pre><code>    repeat i from 0 to n-1
       a[i] := b[i]
</code></pre>
<p>is converted to the equivalent of</p>
<pre><code>    aptr := @a[0]
    bptr := @b[0]
    repeat n
      long[aptr] := long[bptr]
      aptr += 4
      bptr += 4
</code></pre>
<h4 id="multiply-to-addition">Multiply to addition</h4>
<p>An expression like <code>(i*100)</code> where <code>i</code> is a loop index can be converted to something like <code>itmp \ itmp + 100</code></p>
<h3 id="per-function-control-of-optimizations">Per-function control of optimizations</h3>
<p>It is possible to enable or disable individual optimizations in a function by using attributes. For example, to disable loop reduction for a particular C function, one would add an attribute:</p>
<pre><code>int foo(int x) __attribute__(opt(!loop-reduce)) {
...
}
</code></pre>
<p>A similar effect is achieved in Spin by adding a comment <code>{++opt(!loop-reduce)}</code> between the <code>pub</code> or <code>pri</code> and the function name.</p>
<p>In BASIC we use the <code>for</code> keyword followed by a string giving the optimization options:</p>
<pre><code>function for &quot;opt(!loop-reduce)&quot; myfunc()
</code></pre>
<p>Multiple options may be given, separated by commas. To turn an option off, prefix it with <code>!</code> or with <code>~</code>. To enable all options for a particular optimization level, start the string with <code>0</code>, <code>1</code>, <code>2</code>, etc., or with the word <code>all</code> to enable all optimizations (regardless of the compiler optimization level chosen).</p>
<p>Thus, a Spin function with <code>{++opt(0,peephole)}</code> will always be compiled with no optimization except peepholes, even when the <code>-O2</code> option is given to the compiler.</p>
<h3 id="optimization-control-on-the-command-line">Optimization control on the command line</h3>
<p>Multiple <code>-O</code> options may be given, or combined separated by commas. So for example to compile with no optimizations except basic register and peephole, one would give <code>-O0,regs,peephole</code>. To compile with <code>-O2</code> but with peepholes turned off, one would give <code>-O2,!peephole</code>.</p>
<h3 id="optimizing-for-size">Optimizing for size</h3>
<p>The <code>-Os</code> option enables all of the optimizations specified by <code>-O1</code>, plus some size related optimizations.</p>
<h2 id="memory-allocation-and-management">Memory Allocation and Management</h2>
<p>There are some built in functions for doing memory allocation. These are intended for C or BASIC, but may be used by Spin programs as well.</p>
<h3 id="heap-allocation">Heap allocation</h3>
<p>The main function is <code>_gc_alloc_managed(siz)</code>, which allocates <code>siz</code> bytes of memory managed by the garbage collector. It returns 0 if not enough memory is avilable, otherwise returns a pointer to the start of the memory (like C's <code>malloc</code>). As long as there is some reference in COG or HUB memory to the pointer which got returned, the memory will be considered "in use". If there is no more such reference then the garbage collector will feel free to reclaim it. There's also <code>_gc_alloc(siz)</code> which is similar but marks the memory so it will never be reclaimed, and <code>_gc_free(ptr)</code> which explicitly frees a pointer previously allocated by <code>_gc_alloc</code> or <code>_gc_alloc_managed</code>.</p>
<p>The size of the heap is determined by a constant <code>HEAPSIZE</code> declared in the top level object. If none is given then a (small) default value is used.</p>
<p>Example:</p>
<pre><code>&#39; put this CON in the top level object to specify how much memory should be provided for
&#39; memory allocation (the &quot;heap&quot;). The default is 4K on P2, 256 bytes on P1
CON
   HEAPSIZE = 32768 &#39; or however much memory you want to provide for the allocator

&#39; here&#39;s a function to allocate memory
&#39; &quot;siz&quot; is the size in bytes
PUB allocmem(size) : ptr
  ptr := _gc_alloc_managed(size)
</code></pre>
<p>The garbage collection functions and heap are only included in programs which explicitly ask for them.</p>
<h3 id="heap-size-specification">Heap size specification</h3>
<p>In SPIN:</p>
<pre><code>   CON HEAPSIZE=32768
</code></pre>
<p>In BASIC:</p>
<pre><code>  const HEAPSIZE=32768
</code></pre>
<p>In C:</p>
<pre><code>   enum { HEAPSIZE=32768 };
</code></pre>
<p>The C version is a little unexpected; one would expect HEAPSIZE to be declared as <code>const int</code> or with <code>#define</code>. This is a technical limitation that I hope to fix someday.</p>
<h3 id="garbage-collection">Garbage collection</h3>
<p>The garbage collector works by scanning memory for tagged pointers into the heap area; these pointers are assumed to be in use, whereas memory in the heap that is allocated but has no pointers to it in RAM are assumed to be garbage and are automatically freed during collection.</p>
<p>Garbage collection happens automatically when the <code>_gc_alloc()</code> function finds there is not enough memory to fulfil are request. This can take quite a bit of time, so it is best to avoid memory allocation requests (e.g. BASIC string operations) inside time critical code.</p>
<p>It is also possible to manually trigger a garbage collection request by calling <code>_gc_collect()</code>. After this as much memory as possible is freed.</p>
<h3 id="stack-allocation">Stack allocation</h3>
<p>Temporary memory may be allocated on the stack by means of the call <code>__builtin_alloca(siz)</code>, which allocates <code>siz</code> bytes of memory on the stack. This is like the C <code>alloca</code> function. Note that the pointer returned by <code>__builtin_alloca</code> will become invalid as soon as the current function returns, so it should not be placed in any global variable (and definitely should not be returned from the function!)</p>
<h2 id="terminal-control">Terminal Control</h2>
<p>The FlexProp system uses the default system terminal, configured when possible to accept VT100 (ANSI) escape sequences.</p>
<h3 id="changing-baud-rate">Changing baud rate</h3>
<p>All languages have a <code>_setbaud(N)</code> function to set the baud rate to <code>N</code>.</p>
<h3 id="changing-echo-and-crlf-interpretation">Changing echo and CR/LF interpretation</h3>
<p>Normally input (e.g. from a C <code>getchar()</code>) is echoed back to the screen, and carriage return (ASCII 13) is converted to line feed (ASCII 10). Both of these behaviors may be changed via the <code>_setrxtxflags(mode)</code> function. The bits in <code>mode</code> control terminal behavior: if <code>mode &amp; 1</code> is true, then characters are echoed, and if <code>mode &amp; 2</code> is true then carriage return (CR) is converted to line feed (LF) on input, and line feed is converted to CR + LF on output.</p>
<p>The current state of the flags may be retrieved via <code>_getrxtxflags()</code>.</p>
<h2 id="character-set">Character Set</h2>
<p>The input character set for the compiler is assumed to be UTF-8, or Windows UCS2 (16 bit Unicode).</p>
<p>The character set to use at runtime is set by the compiler switch <code>--charset=C</code>, and may be one of <code>utf8</code> (the default), <code>latin1</code> (for ISO_8859-1), <code>shiftjis</code> (for Shift-JIS 2004), or <code>parallax</code> (for the Parallax font). For example, if you are using a VGA graphics program with the Parallax font, you would typically use <code>--charset=parallax</code>. This would cause any strings in the program to be translated from UTF-8 (the input character set) to the Parallax font encoding.</p>
<h2 id="file-io-p2-only">File I/O (P2 Only)</h2>
<p>C and BASIC have built in support for accessing file systems. The file systems first must be given a name with the <code>mount</code> system call, and then may be accessed with the normal language functions.</p>
<h3 id="mount">Mount</h3>
<p>The <code>mount</code> call gives a name to a file system. For example, after</p>
<pre><code>mount(&quot;/host&quot;, _vfs_open_host());
mount(&quot;/sd&quot;, _vfs_open_sdcard());
</code></pre>
<p>files on the host PC may be accessed via names like "/host/foo.txt", "/host/bar/bar.txt", and so on, and files on the SD card may be accessed by names like "/sd/root.txt", "/sd/subdir/file.txt", and so on.</p>
<p>This only works on P2, because it requires a lot of HUB memory. Also, the host file server requires features built in to <code>loadp2</code>.</p>
<p>Available file systems are:</p>
<ul>
<li><code>_vfs_open_host()</code> (for the loadp2 Plan 9 file system)</li>
<li><code>_vfs_open_sdcard()</code> for a FAT file system on the P2 SD card (using default pins 58-61)</li>
<li><code>_vfs_open_sdcardx()</code> for a FAT file system on SD card using custom pins</li>
</ul>
<p>It is OK to make multiple mount calls, but they should have different names.</p>
<h3 id="options-for-sd-card">Options for SD Card</h3>
<p>If you define the symbol <code>FF_USE_LFN</code> on the command line with an option like <code>-DFF_USE_LFN</code> then long file names will be enabled for the SD card.</p>
<p>The pins to use for the SD card may be changed by using <code>_vfs_open_sdcardx</code> instead of <code>_vfs_open_sdcard</code>. The parameters for <code>_vfs_open_sdcardx</code> are the clock pin, select pin, data in, and data out pins, in that order. Thus, <code>_vfs_open_sdcard</code> is actually equivalent to <code>_vfs_open_sdcardx(61, 60, 59, 58)</code>.</p>
<h2 id="command-line-options">Command Line Options</h2>
<h3 id="options-for-flexspin">Options for flexspin</h3>
<p>There are various command line options for the compiler which may modify the compilation:</p>
<pre><code>  [ --version ]      print just the compiler version, then exit
  [ -h ]             display this help
  [ -L or -I &lt;path&gt; ] add a directory to the include path
  [ -o ]             output filename
  [ -b ]             output binary file format
  [ -e ]             output eeprom file format
  [ -c ]             output only DAT sections
  [ -l ]             output a .lst listing file
  [ -f ]             output list of file names
  [ -g ]             enable debug statements (default printf method)
  [ -gbrk ]          enable BRK based debugging
  [ -q ]             quiet mode (suppress banner and non-error text)
  [ -p ]             disable the preprocessor
  [ -O[#] ]          set optimization level
                       -O0 disable all optimization
                       -O1 apply default optimization (same as no -O flag)
               -O2 apply all optimization (same as -O)
  [ -Wall ]          enable all warnings, including warnings about language extensions
  [ -Werror ]        turn warnings into errors
  [ -Wabs-paths ]    print absolute paths for file names in errors/warnings
  [ -Wmax-errors=N ] allow at most N errors in a pass before stopping
  [ -D &lt;define&gt; ]    add a define
  [ -2 ]             compile for Prop2
  [ -w ]             produce Spin wrappers for PASM code
  [ -H nnnn ]        change the base HUB address (see below)
  [ -E ]             omit any coginit header
  [ --charset=C ]    set the character set to use at runtime
           C = utf8 for UTF-8 encoding (the default)
       C = latin1 for Latin-1 encoding
       C = parallax for Parallax font encoding
  [ --code=cog  ]    compile to run in COG memory instead of HUB
  [ --fcache=N  ]    set size of FCACHE space in longs (0 to disable)
  [ --fixedreal ]    use 16.16 fixed point instead of IEEE floating point
  [ --lmm=xxx ]      use alternate LMM implementation for P1
           xxx = orig uses original flexspin LMM
           xxx = slow uses traditional (slow) LMM
  [ --nostdlib ]     Do not check for include files in the standard place (../include relative to the flexspin binary)
  [ --tabs=N ]       specifify number of spaces between tab stops (default 8)
</code></pre>
<p><code>flexspin.exe</code> checks the name it was invoked by. If the name starts with the string "bstc" (case matters) then its output messages mimic that of the bstc compiler; otherwise it tries to match openspin's messages. This is for compatibility with Propeller IDE. For example, you can use flexspin with the PropellerIDE by renaming <code>bstc.exe</code> to <code>bstc.orig.exe</code> and then copying <code>flexspin.exe</code> to <code>bstc.exe</code>.</p>
<h3 id="options-for-flexcc">Options for flexcc</h3>
<p><code>flexcc</code> is similar to <code>flexspin</code>, but has arguments more like the traditional <code>cc</code> command line compiler.</p>
<pre><code>  [ --help ]         display this help
  [ -c ]             output only .o file
  [ -D &lt;define&gt; ]    add a define
  [ -g ]             include debug info in output
  [ -L or -I &lt;path&gt; ] add a directory to the include path
  [ -o &lt;name&gt; ]      set output filename to &lt;name&gt;
  [ -2 ]             compile for Prop2
  [ -O# ]            set optimization level:
          -O0 = no optimization
          -O1 = basic optimization
          -O2 = all optimization
  [ -Wall ]          enable warnings for language extensions and other features
  [ -Werror ]        make warnings into errors
  [ -Wabs-paths ]    print absolute paths for file names in errors/warnings
  [ -Wmax-errors=N ] allow at most N errors in a pass before stopping
  [ -x ]             capture program exit code (for testing)
  [ --code=cog ]     compile for COG mode instead of LMM
  [ --fcache=N ]     set FCACHE size to N (0 to disable)
  [ --fixedreal ]    use 16.16 fixed point in place of floats
  [ --lmm=xxx ]      use alternate LMM implementation for P1
           xxx = orig uses original flexspin LMM
           xxx = slow uses traditional (slow) LMM
  [ --nostdlib ]     Do not check for include files in the standard place (../include relative to the flexcc binary)
  [ --version ]      just show compiler version
</code></pre>
<h3 id="changing-hub-address">Changing Hub address</h3>
<p>In P2 mode, you may want to change the base hub address for the binary. Normally P2 binaries start at the standard offset of <code>0x400</code>, with memory from <code>0</code> to <code>0x400</code> being used by the initial startup code. But if you want, for example, to load a flexspin compiled program from TAQOZ or some similar program, you may want to start at a different address (TAQOZ uses the first 64K of RAM). To do this, you may use some combination of the <code>-H</code> and <code>-E</code> flags.</p>
<p><code>-H nnnn</code> changes the base HUB address from <code>0x400</code> to <code>nnnn</code>, where <code>nnnn</code> is either a decimal number like <code>65536</code> or a hex number prefixed with <code>0x</code>. By default the binary still expects to be loaded at address 0, so it starts with a <code>coginit #0, ##nnnn</code> instruction and then zero padding until the hub start. To skip the <code>coginit</code> and padding, add the <code>-E</code> flag.</p>
<h4 id="example">Example</h4>
<p>To compile a program to start at address 65536 (at the 64K boundary), do:</p>
<pre><code>flexspin -2 -H 0x10000 -E fibo.bas
</code></pre>
<h2 id="common-low-level-functions">Common low level functions</h2>
<p>A number of low level functions are available in all languages. The C prototypes are given below, but they may be called from any language and are always available. If a user function with the same name is provided, the built-in function will not be available from user code (but internally the libraries <em>may</em> continue to use the built-in version; this isn't defined).</p>
<p>Unless otherwise noted, these functions are available for both P1 and P2.</p>
<h3 id="serial-port-access">Serial port access</h3>
<h4 id="_txraw">_txraw</h4>
<pre><code>int _txraw(int c)
</code></pre>
<p>sends character <code>c</code> out the default serial port. Always returns 1.</p>
<h4 id="_rxraw">_rxraw</h4>
<pre><code>int _rxraw(int n=0)
</code></pre>
<p>Receives a character on the default serial port. <code>n</code> is a timeout in milliseconds. If the timeout elapses with no character received, <code>_rxraw</code> returns -1, otherwise it returns the received character. The default timeout (0) signifies "forever"; that is, if <code>n</code> is 0 the <code>_rxraw</code> function will wait as long as necessary until a character is received.</p>
<h4 id="_setbaud">_setbaud</h4>
<pre><code>void _setbaud(int rate)
</code></pre>
<p>Sets the baud rate on the default serial port to <code>rate</code>. For example, to change the serial port to 115200 baud you would call <code>_setbaud(115200)</code>. The default rates set up in C and BASIC initialization code are are 115200 for P1 and 230400 for P2. In Spin you may need to call <code>_setbaud</code> explicitly before calling <code>_rxraw</code> or <code>_txraw</code>.</p>
<h3 id="time-related-functions">Time related functions</h3>
<h4 id="_getsec">_getsec</h4>
<p>Gets elapsed seconds since the system was booted. Uses the system clock, which wraps around after about 50 seconds on the P1.</p>
<h4 id="_getms">_getms</h4>
<p>Gets elapsed milliseconds since boot.</p>
<h4 id="_getus">_getus</h4>
<p>Gets elapsed microseconds since boot.</p>
<h4 id="_waitx">_waitx</h4>
<pre><code>void _waitx(unsigned cycles)
</code></pre>
<p>Pauses for <code>cycles</code> cycles. Note that the maximum waiting period is about half of the system clock frequency.</p>
<h4 id="_waitms">_waitms</h4>
<pre><code>void _waitms(unsigned ms)
</code></pre>
<p>Wait for <code>ms</code> milliseconds. For waits of more than a second, this function will loop internally so as to avoid limits of the 32 bit clock counter.</p>
<h4 id="_waitus">_waitus</h4>
<pre><code>void _waitus(unsigned us)
</code></pre>
<p>Wait for <code>us</code> microseconds. For waits of more than a second, this function will loop internally so as to avoid limits of the 32 bit clock counter.</p>
<h3 id="cog-control">Cog control</h3>
<h4 id="_cogchk">_cogchk</h4>
<pre><code>int _cogchk(int id)
</code></pre>
<p>Checks to see if cog number id is running. Returns -1 if running, 0 if not.</p>
<p>This function may be relatively slow on P1, as it has to manually probe the COGs (on P2 it's a built in instruction).</p>
</body>
</html>
